<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WAZIUP Irrigation Dashboard</title>
    <meta name="description" content="WAZIUP Irrigation Prediction Dashboard" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="styles.css" type="text/css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <script type="text/javascript" src="libs/jquery-3.2.1.min.js"></script>
    <script type="text/javascript" src="libs/apexcharts.min.js"></script>

    <script type="text/javascript">
      var waitForTraining = true;
      var timestamp = "";
      var MaxValuesToBeDisplayed = 1000;
      let chartHist = null;
      let chartDataSet = null;
      let chartPred = null;
      let chartHistLoaded = false,
        chartDataSetLoaded = false,
        chartPredLoaded = false;
      var TrainingReadyCheck = 10000;
      let tabCounter = 0;

      // Event listeners
      document.addEventListener("DOMContentLoaded", function () {
        // Tooltips
        fetch("tooltips.json")
          .then((response) => response.json())
          .then((tooltips) => {
            document.querySelectorAll(".tooltip").forEach((tooltip) => {
              const tooltipId = tooltip.getAttribute("data-tooltip-id");
              if (tooltips[tooltipId]) {
                tooltip.querySelector(".tooltiptext").textContent =
                  tooltips[tooltipId];
              }
            });
          })
          .catch((error) =>
            console.error("Error loading tooltip text:", error)
          );

        // Get plots formerly saved
        fetch(`../api/getPlots`)
          .then((response) => response.json())
          .then((data) => {
            if (data.tabnames.length == 0) {
              addTab("Plot 1");
              fetch(`../api/addPlot`)
                .then((response) => response.json())
                .then((data) => {
                  console.log(
                    "Next Plot was added with nr: ",
                    data.next_number
                  );
                });
              switchTab(1);
            } else {
              const tabPromises = data.tabnames.map((name) => {
                return new Promise((resolve) => {
                  addTab(name);
                  resolve();
                });
              });
              return Promise.all(tabPromises);
            }
          })
          .then(() => {
            return fetch(`../api/getCurrentPlot`);
          })
          .then((response) => response.json())
          .then((currentPlotData) => {
            const currentTabId = currentPlotData["currentPlot"];
            const tabExists = document.getElementById(`tab-${currentTabId}`);

            if (tabExists) {
              switchTab(currentTabId);
            } else {
              console.warn(
                `Tab ${currentTabId} not found, defaulting to first`
              );
              switchTab(1);
            }
          })
          .catch((error) => {
            console.error("Error in tab initialization:", error);
            switchTab(1);
          });

        // Add plot when add button is clicked
        document
          .getElementById("addTabButton")
          .addEventListener("click", () => {
            const tabId = ++tabCounter;
            const newTab = document.createElement("div");
            newTab.id = `tab-${tabId}`;
            newTab.className = "tab";
            newTab.textContent = `Plot ${tabId}`;
            newTab.addEventListener("click", () => switchTab(tabId));
            document.getElementById("tabs").appendChild(newTab);

            fetch(`../api/addPlot`, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: `tab_nr=${tabId}`,
            })
              .then((response) => response.json())
              .then((data) => {
                console.log("Next Plot was added with nr: ", data.next_number);
              })
              .catch((error) => {
                console.error("Error, could not add plot_nr: ", error);
              });

            switchTab(tabId);
          });
      });

      function addTab(name) {
        const tabId = ++tabCounter;
        const newTab = document.createElement("div");
        newTab.id = `tab-${tabId}`;
        newTab.className = "tab";

        const tabLabel = document.createElement("span");
        tabLabel.textContent = name;
        tabLabel.addEventListener("click", () => switchTab(tabId));

        const closeButton = document.createElement("span");
        closeButton.className = "close-tab";
        closeButton.innerHTML = "&times;";
        closeButton.addEventListener("click", (event) => {
          event.stopPropagation();
          removeTab(tabId);
        });

        newTab.appendChild(tabLabel);
        newTab.appendChild(closeButton);
        document.getElementById("tabs").appendChild(newTab);
        return newTab.id;
      }

      function clearTabContent() {
        document.getElementById("chart_hist").innerHTML = "";
        document.getElementById("chart_pred").innerHTML = "";

        if (chartHist) {
          chartHist.destroy();
          chartHist = null;
        }
        if (chartPred) {
          chartPred.destroy();
          chartPred = null;
        }

        document.getElementById("temp-value").textContent = "--";
        document.getElementById("tension-value").textContent = "--";
        document.getElementById("humidity-value").textContent = "--";
        document.getElementById("timestamp_txt").textContent = "";
      }

      function switchTab(tabId) {
        const currentTab = document.getElementById(`tab-${tabId}`);
        if (currentTab && currentTab.classList.contains("active")) {
          return;
        }

        clearTabContent();
        document.querySelector(".main-content").classList.remove("loaded");
        document.getElementById("loading-indicator").style.display = "block";

        document.querySelectorAll(".tab").forEach((tab) => {
          tab.classList.remove("active");
          const closeButton = tab.querySelector(".close-tab");
          if (closeButton) {
            closeButton.remove();
          }
        });

        if (currentTab) {
          currentTab.classList.add("active");
          const closeButton = document.createElement("span");
          closeButton.className = "close-tab";
          closeButton.innerHTML = "&times;";
          closeButton.addEventListener("click", (event) => {
            event.stopPropagation();
            removeTab(tabId);
          });
          currentTab.style.position = "relative";
          currentTab.appendChild(closeButton);
        }

        fetch(`../api/setPlot`, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `currentPlot=${tabId}`,
        })
          .then((response) => response.text())
          .then((data) => {
            console.log(data);
            loadStuff();
          })
          .catch((error) => {
            console.error("Error, could not set plot_nr: ", error);
          });
      }

      function removeTab(tabId) {
        const tabToRemove = document.getElementById(`tab-${tabId}`);
        if (tabToRemove) {
          tabToRemove.remove();
          if (tabToRemove.classList.contains("active")) {
            const remainingTabs = document.querySelectorAll(".tab");
            if (remainingTabs.length > 0) {
              const nextTab = remainingTabs[remainingTabs.length - 1];
              const nextTabId = nextTab.id.split("-")[1];
              switchTab(nextTabId);
            }
          }
          fetch(`../api/removePlot`, {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
            },
            body: `currentPlot=${tabId}`,
          })
            .then((response) => response.text())
            .then((data) => console.log(data))
            .catch((error) => console.error("Error in removeTab():", error));
        }
      }

      function goToSettings() {
        window.location.href = "settings.html";
      }

      function stateConfigPresent() {
        const set_button = document.getElementById("settings_btn");
        set_button.classList.remove("highlight");
        const train_button = document.getElementById("train_btn");
        // Instead of replacing all classes, just remove highlight and keep styling
        train_button.className = "train-button modern-train-btn";
        train_button.disabled = false;
      }

      function stateConfigNotPresent() {
        document.getElementById("loading-indicator").style.display = "none";
        document.querySelector(".main-content").classList.add("loaded");
        alert(
          "Please press the 'Settings' button and set up the needed parameters."
        );
        const set_button = document.getElementById("settings_btn");
        set_button.classList.add("highlight");
        const train_button = document.getElementById("train_btn");
        // Keep the styling classes and add disabled state
        train_button.className = "train-button modern-train-btn";
        train_button.disabled = true;
      }

      function checkConfigPresent() {
        return fetch(`../api/checkConfigPresent`)
          .then((response) => response.json())
          .then((data) => {
            if (data.data.config_present == true) {
              stateConfigPresent();
              return true;
            } else {
              stateConfigNotPresent();
            }
            console.log(data);
            return false;
          });
      }

      function checkActiveIrrigation() {
        return fetch(`../api/checkActiveIrrigation`)
          .then((response) => response.json())
          .then((data) => {
            if (data.data.activeIrrigation == true) {
              return true;
            } else {
              const text = document.getElementById("pump-status");
              const button = document.getElementById("schedule_irrigation");
              text.className = "status-inactive";
              text.innerText = "Inactive - No present";
              button.className = "button-cancel";
              button.disabled = true;
              return false;
            }
            console.log(data);
          });
      }

      function formatTimestamp(isoTimestamp) {
        const date = new Date(isoTimestamp);
        const options = {
          year: "numeric",
          month: "short",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
        };
        const formatter = new Intl.DateTimeFormat("de-DE", options);
        return formatter.format(date);
      }

      function fetchCurrentValues() {
        fetch("../api/getValuesForDashboard")
          .then((response) => response.json())
          .then((dashboardData) => {
            document.getElementById("temp-value").textContent = parseFloat(
              dashboardData.temp_average
            ).toFixed(2);
            document.getElementById("tension-value").textContent = parseFloat(
              dashboardData.moisture_average
            ).toFixed(2);
            document.getElementById("humidity-value").textContent = parseFloat(
              dashboardData.vwc_average
            ).toFixed(2);
          })
          .catch((error) => console.error("Error fetching data:", error));
      }

      function fetchHistoricalChartData() {
        if (chartHist) {
          chartHist.destroy();
        }

        fetch("../api/getHistoricalChartData")
          .then((response) => response.json())
          .then((chartData) => {
            const chartContainer = document.getElementById("chart_hist");
            if (chartData.available == false) {
              chartContainer.innerHTML = "";
              chartContainer.style.display = "none";
            } else {
              chartContainer.style.display = "block";

              const totalValues = chartData.timestamps.length;
              if (totalValues > MaxValuesToBeDisplayed) {
                const step = Math.ceil(totalValues / MaxValuesToBeDisplayed);
                chartData.timestamps = chartData.timestamps.filter(
                  (timestamp, index) => index % step === 0
                );
                chartData.temperatureSeries =
                  chartData.temperatureSeries.filter(
                    (value, index) => index % step === 0
                  );
                chartData.moistureSeries = chartData.moistureSeries.filter(
                  (value, index) => index % step === 0
                );
              }

              const temperatureSeriesRounded = chartData.temperatureSeries.map(
                (value) => parseFloat(value.toFixed(1))
              );
              const moistureSeriesRounded = chartData.moistureSeries.map(
                (value) => parseFloat(value.toFixed(2))
              );
              const formattedTimestamps = chartData.timestamps.map(
                (timestamp) => formatTimestamp(timestamp)
              );

              const options = {
                chart: {
                  type: "line",
                  height: 300,
                  toolbar: {
                    show: true,
                    tools: {
                      download: true,
                      selection: true,
                      zoom: true,
                      zoomin: true,
                      zoomout: true,
                      pan: true,
                      reset: true,
                    },
                  },
                  fontFamily: "Inter, sans-serif",
                },
                series: [
                  {
                    name: "Temperature in °C",
                    data: temperatureSeriesRounded,
                    color: "#3498db",
                  },
                  {
                    name: chartData.unit,
                    data: moistureSeriesRounded,
                    color: "#2ecc71",
                  },
                ],
                xaxis: {
                  categories: formattedTimestamps,
                  labels: {
                    rotate: -45,
                    minHeight: 40,
                    style: {
                      fontSize: "12px",
                      fontFamily: "Inter, sans-serif",
                    },
                  },
                },
                yaxis: {
                  labels: {
                    style: {
                      fontSize: "12px",
                      fontFamily: "Inter, sans-serif",
                    },
                  },
                },
                stroke: {
                  curve: "smooth",
                  width: 2,
                },
                grid: {
                  borderColor: "#f1f1f1",
                },
                legend: {
                  position: "bottom",
                  horizontalAlign: "center",
                  fontFamily: "Inter, sans-serif",
                },
              };

              document.getElementById("loading-indicator").style.display =
                "none";
              document.querySelector(".main-content").classList.add("loaded");

              chartHist = new ApexCharts(
                document.querySelector("#chart_hist"),
                options
              );
              chartHist.render();
            }
          })
          .catch((error) => console.error("Error fetching data:", error));
      }
      // TODO: keys are wrong, data missing
      function fetchDatasetChartData() {
        // Destroy existing chart instance
        if (chartDataSet) {
          chartDataSet.destroy();
        }

        fetch("../api/getDatasetChartData")
          .then((response) => response.json())
          .then((chartData) => {
            const chartContainer = document.getElementById('chart_train_data');
            if (chartData.model == false) {
              chartContainer.innerHTML = "";            // Clears the chart div
              chartContainer.style.display = "none";    // Hide the div
            } else {
              chartContainer.style.display = "block";   // Show it when there’s data
              // Initialize variables outside the loop
              var elementsToDisplay = [];
              var formattedTimestamps;
              const totalValues = chartData.timestamps.length;
              const step = Math.ceil(totalValues / MaxValuesToBeDisplayed);

              // Iterate through the keys in chartData
              for (var key in chartData) {
                if (chartData.hasOwnProperty(key)) {
                  // Check the type for each element in the array
                  var isNumberArray = chartData[key].every(
                    (value) => typeof value === "number"
                  );

                  if (isNumberArray) {
                    if (totalValues > MaxValuesToBeDisplayed) {
                      chartData[key] = chartData[key].filter((value, index) => index % step === 0);
                    }
                    // If all elements are numbers, push the series data
                    elementsToDisplay.push({
                      name: key,
                      data: chartData[key].map((value) =>
                        parseFloat(value.toFixed(2))
                      ),
                    });
                  } else if (typeof chartData[key][0] === "string") {
                    if (totalValues > MaxValuesToBeDisplayed) {
                      chartData[key] = chartData[key].filter((value, index) => index % step === 0);
                    }
                    formattedTimestamps = chartData.timestamps.map(
                      (timestamp) => formatTimestamp(timestamp)
                    );
                  }
                }
              }

              var options = {
                chart: {
                  type: "line",
                  title: "All values of the dataset", // Set the title here
                },
                series: elementsToDisplay, // Use the prepared series data
                xaxis: {
                  categories: formattedTimestamps || [], // Use formattedTimestamps if available, otherwise an empty array
                  labels: {
                    rotate: -45,
                    minHeight: 40,
                  },
                },
              };

              chartDataSet = new ApexCharts(
                document.querySelector("#chart_train_data"),
                options
              );
              chartDataSet.render();

              // Hide some series after rendering
              chartDataSet.hideSeries("hour");
              chartDataSet.hideSeries("Cloudcover");
              chartDataSet.hideSeries("Shortwave_Radiation");
              chartDataSet.hideSeries("Soil_temperature_7-28");
              chartDataSet.hideSeries("Soil_moisture_0-7");
              chartDataSet.hideSeries("Et0_evapotranspiration");
            }
          })
          .catch((error) => console.error("Error fetching data:", error));
      }

      // Fetch prediction chart data
      function fetchPredictionChartData() {
        // Destroy existing chart instance
        if (chartPred) {
          chartPred.destroy();
          chartPred = null;
        }

        fetch("../api/getPredictionChartData")
          .then((response) => response.json())
          .then((chartData) => {
            const chartContainer = document.getElementById('chart_pred');
            chartContainer.innerHTML = "";            // Clears the chart div
            if (chartData.model === false) {
              chartContainer.style.display = "none";    // Hide the div
              // highlight train
              const trainButton = document.getElementById("train_btn");
              trainButton.classList.add("highlight");
              alert('Please start training by pressing the "Start Training" button.'); //TODO: this needs to be capsulated and also checked for training in progress REFINE!!!
            } else {
              chartContainer.style.display = "block";   // Show it when there’s data
              // Format the data
              const moistureSeriesRounded = chartData.moistureSeries.map((value) =>
                parseFloat(value.toFixed(2))
              );
              let moistureSeriesVolRounded = null;
              if (chartData.kind === "tension" && Array.isArray(chartData.moistureSeriesVol)) {
                moistureSeriesVolRounded = chartData.moistureSeriesVol.map((value) =>
                  parseFloat(value.toFixed(4))
                );
              }
              const formattedTimestamps = chartData.timestamps.map((timestamp) =>
                formatTimestamp(timestamp)
              );

              // Initialize series visibility state TODO: check for capcitive
              const seriesVisibility = {
                "Moisture in cbar (Soil Tension)": true,
                "Volumetric Water Content": false,
              };

              // Configure chart options
              const options = {
                chart: {
                  type: "line",
                  events: {
                    render: function (chartContext, config) {
                      // Make sure the series exists before calling hideSeries
                      if (chartData.kind === "tension" && moistureSeriesVolRounded) {
                        chartPred.hideSeries("Volumetric Water Content");
                      }
                    },
                    legendClick: function (chartContext, seriesIndex) {
                      const seriesName = chartContext.w.globals.seriesNames[seriesIndex];
                      // Toggle visibility state for the clicked series
                      seriesVisibility[seriesName] = !seriesVisibility[seriesName];

                      // Determine the new annotations
                      const annotations = seriesVisibility["Moisture in cbar (Soil Tension)"]
                        ? getSoilTensionAnnotations(chartData)
                        : [];

                      // Additional annotations from backend, like 
                      const additionalAnnotations = seriesVisibility["Moisture in cbar (Soil Tension)"]
                        ? chartData.annotations.yaxis
                        : [];

                      // Update the chart annotations
                      chartContext.updateOptions({
                        annotations: {
                          yaxis: [...annotations, ...additionalAnnotations],
                        },
                      });
                    },
                  },
                },
                series: [
                  {
                    name: chartData.unit,
                    data: moistureSeriesRounded,
                  },
                  ...(moistureSeriesVolRounded
                    ? [
                      {
                        name: "Volumetric Water Content",
                        data: moistureSeriesVolRounded,
                      },
                    ]
                    : []),
                ],
                xaxis: {
                  categories: formattedTimestamps,
                  labels: {
                    rotate: -45,
                    minHeight: 40,
                  },
                },
                yaxis: [
                  {
                    title: {
                      text: chartData.unit,
                    },
                    labels: {
                      formatter: function (val) {
                        return typeof val === "number" && !isNaN(val) ? val.toFixed(1) : "";
                      },
                    },
                    min: 0,
                    max: Math.max(...moistureSeriesRounded),
                  },
                  ...(moistureSeriesVolRounded
                    ? [
                      {
                        opposite: true,
                        title: {
                          text: "Volumetric Water Content",
                        },
                        labels: {
                          formatter: function (val) {
                            return typeof val === "number" && !isNaN(val)
                              ? val.toFixed(2)
                              : "";
                          },
                        },
                        min: Math.min(...moistureSeriesVolRounded).toFixed(0),
                        max: Math.max(...moistureSeriesVolRounded).toFixed(0),
                      },
                    ]
                    : []),
                ],
                annotations: {
                  yaxis: [
                    ...(() => {
                      if (chartData.kind === 'tension') {
                        // Combine both soil tension annotations and the other y-axis annotations
                        const soilTensionAnnotations = getSoilTensionAnnotations(chartData);
                        const additionalAnnotations = Array.isArray(chartData.annotations?.yaxis)
                          ? chartData.annotations.yaxis
                          : [];
                        return [...soilTensionAnnotations, ...additionalAnnotations];
                      }
                      // Return only the additional annotations if not tension
                      return Array.isArray(chartData.annotations?.yaxis)
                        ? chartData.annotations.yaxis
                        : [];
                    })(),
                  ],
                  xaxis: getMidnightAnnotations(chartData.timestamps), // Add midnight annotations here
                  legend: {
                    show: true, // Ensure the legend is always shown
                  },
                }
              };

              chartPred = new ApexCharts(
                document.querySelector("#chart_pred"),
                options
              );
              chartPred.render();
            }
          })
          .catch((error) => console.error("Error fetching data:", error));
        }

        // Function to get midnight annotations
        function getMidnightAnnotations(timestamps) {
          days = 0
          return timestamps
            .filter((timestamp) => new Date(timestamp).getHours() === 0 && new Date(timestamp).getMinutes() === 0)
            .map((midnight) => ({
              x: formatTimestamp(midnight),
              borderColor: '#FF5733', // Choose any color you like for midnight lines
              strokeDashArray: 4, // Dashed lines
            }));
        }

        // Get active series dynamically
        function getActiveSeries(chartContext) {
          const activeSeries = [];
          chartContext.w.globals.seriesNames.forEach((name, index) => {
            // A series is active if its value is not null
            if (chartContext.w.globals.series[index] !== null) {
              activeSeries.push(name);
            }
          });
          return activeSeries;
        }

        // Initial annotations function
        function getInitialAnnotations(chartData) {
          if (chartData.kind === "tension") {
            return getSoilTensionAnnotations(chartData);
          }
          return [];
        }

        // Function to get annotations for soil tension with colored areas
        function getSoilTensionAnnotations(chartData) {
          return [
            // Area between Saturation and Field Capacity Lower
            {
              y: chartData.fieldCapacityLower,
              borderColor: "transparent",
              label: {
                text: "Saturation",
                style: {
                  fontSize: "12px",
                },
                position: 'right', // Align to the right
                offsetY: 50, // Vertical offset for middle alignment
                offsetX: 0, // Horizontal offset for right alignment
              },
              offsetX: 0,
              offsetY: 0,
              shape: 'rect',
              x: chartData.timestamps.length - 1, // Rightmost position to cover the area
              fillColor: "rgba(173, 216, 255, 0.5)", // Color for this area (light blue)
              y2: chartData.saturation, // Ending y value to create the filled area
            },
            // Area between Field Capacity Lower and Field Capacity Upper
            {
              y: chartData.fieldCapacityUpper,
              borderColor: "transparent",
              label: {
                text: "Field Capacity Lower",
                style: {
                  fontSize: "12px",
                },
                position: 'right', // Align to the right
                offsetY: 50, // Vertical offset for middle alignment
                offsetX: 0, // Horizontal offset for right alignment
              },
              offsetX: 0,
              offsetY: 0,
              shape: 'rect',
              x: chartData.timestamps.length - 1, // Rightmost position to cover the area
              fillColor: "rgba(144, 238, 144, 0.5)", // Color for this area (light green)
              y2: chartData.fieldCapacityLower, // Ending y value to create the filled area
            },
            {
              y: chartData.permanentWiltingPoint,
              borderColor: "transparent",
              label: {
                text: "Field Capacity Higher",
                style: {
                  fontSize: "12px",
                },
                position: 'right', // Align to the right
                offsetY: 50, // Vertical offset for middle alignment
                offsetX: 0, // Horizontal offset for right alignment
              },
              offsetX: 0,
              offsetY: 0,
              shape: 'rect',
              x: chartData.timestamps.length - 1, // Rightmost position to cover the area
              fillColor: "rgba(255, 200, 124, 0.5)", // Color for this area (light orange)
              y2: chartData.fieldCapacityUpper, // Ending y value to create the filled area
            },
            {
              y: Math.max(...chartData.moistureSeries).toFixed(0),
              borderColor: "transparent",
              label: {
                text: "Permanent Wilting Point",
                style: {
                  fontSize: "12px",
                },
                position: 'right', // Align to the right
                offsetY: 50, // Vertical offset for middle alignment
                offsetX: 0, // Horizontal offset for right alignment
              },
              offsetX: 0,
              offsetY: 0,
              shape: 'rect',
              x: chartData.timestamps.length - 1, // Rightmost position to cover the area
              fillColor: "rgba(255, 182, 193, 0.5)", // Color for this area (light red)
              y2: chartData.permanentWiltingPoint // Ending y value to create the filled area
            },
          ];
        }


      function fetchThreshold() {
        fetch("../api/getThreshold")
          .then((response) => response.json())
          .then((timestamp_data) => {
            if (timestamp_data.threshold == false) {
              console.log(
                "No timestamp, when threshold is reached, could be fetched from backend."
              );
              document.getElementById("timestamp_txt").innerHTML =
                "The threshold is not reached in the current forecast horizon.";
            } else {
              document.getElementById("timestamp_txt").innerHTML =
                "The threshold will be reached on " + timestamp_data.timestamp;
            }
          });
      }

      function irrigateManually() {
        const inputElement = document.getElementById("irrigation_value_form");
        const amount = parseInt(inputElement.value, 10);

        if (!isNaN(amount)) {
          fetch(`../api/irrigateManually?amount=${amount}`)
            .then((response) => response.text())
            .then((data) => {
              const dataObject = JSON.parse(data);
              if (dataObject.status == "success") {
                alert(
                  "Manual Irrigation was scheduled, will be performed within the next uplink cycle. Do not press this button again until irrigation is completed."
                );
              } else {
                alert(
                  "Cannot schedule irrigation, see console for more info! Error:",
                  data
                );
              }
              console.log(data);
            })
            .catch((error) => {
              console.error("Error:", error);
              alert("An error occurred during the request. Please try again.");
            });
        } else {
          alert("First type a valid amount in liters to be irrigated!");
        }
      }

      function startTraining() {
        const train_button = document.getElementById("train_btn");

        // Disable the button immediately when training starts
        train_button.disabled = true;
        train_button.classList.remove("highlight");
        train_button.innerHTML = `
          <span class="material-symbols-outlined">psychology</span>
          <span class="btn-text">Training...</span>
          <div class="btn-ripple"></div>
        `;

        fetch(`../api/startTraining`)
          .then((response) => response.text())
          .then((data) => {
            if (data == "") {
              alert(
                "Training process was started, page will reload when procedure is finished!"
              );
              waitForTraining = true;
              isTrainingReady();
            } else {
              // Re-enable button if there's an error
              train_button.disabled = false;
              train_button.innerHTML = `
                <span class="material-symbols-outlined">psychology</span>
                <span class="btn-text">Start Training</span>
                <div class="btn-ripple"></div>
              `;
              alert("Cannot start, see console for more info! Error:", data);
            }
            console.log(data);
          })
          .catch((error) => {
            // Re-enable button if there's an error
            train_button.disabled = false;
            train_button.innerHTML = `
              <span class="material-symbols-outlined">psychology</span>
              <span class="btn-text">Start Training</span>
              <div class="btn-ripple"></div>
            `;
            console.error("Error starting training:", error);
          });
      }

      async function isTrainingReady() {
        const train_button = document.getElementById("train_btn");

        while (waitForTraining) {
          fetch(`../api/isTrainingReady`)
            .then((response) => response.json())
            .then((response_data) => {
              if (response_data.isTrainingFinished == true) {
                waitForTraining = false;
                // Re-enable button when training is finished
                train_button.disabled = false;
                train_button.innerHTML = `
                  <span class="material-symbols-outlined">psychology</span>
                  <span class="btn-text">Start Training</span>
                  <div class="btn-ripple"></div>
                `;
                loadStuff();
                alert("Training process is finished!");
              }
            });
          await sleep(TrainingReadyCheck);
        }
      }

      function loadStuff() {
        $.get("/devices", function (data) {
          checkConfigPresent()
            .then((ret) => {
              if (ret) {
                console.log("Config is already present...");
                return Promise.all([
                  checkActiveIrrigation(),
                  fetchHistoricalChartData(),
                  fetchCurrentValues(),
                  fetchDatasetChartData(),
                  fetchPredictionChartData(),
                  fetchThreshold(),
                ]);
              }
            })
            .catch((e) => {
              console.log("Config is not present... Error: ", e);
            });
        });
      }

      $(function () {
        $("#sensor_list")
          .html('<img src="./loading.gif" /> Loading...')
          .fadeIn();
      });

      function adjustAmount(change) {
        const input = document.getElementById("irrigation_value_form");
        let currentValue = parseInt(input.value) || 0;
        let newValue = currentValue + change;

        // Safety checks
        if (newValue < 1) {
          newValue = 1;
        }
        if (newValue > 1000) {
          newValue = 1000;
        }

        input.value = newValue;
      }
    </script>
  </head>

  <body>
    <!-- Tab container for plot selection -->
    <div class="tab-container">
      <div id="tabs" class="tabs"></div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="loading-indicator">
      <div class="loading-content">
        <div class="spinner"></div>
        <p>
          Loading the current plot: Getting data from APIs, datasets,
          predictions and models...
        </p>
      </div>
    </div>

    <!-- Main content -->
    <div class="main-content">
      <!-- Header with location and controls -->
      <header class="app-header">
        <!-- Training buttons -->
        <div class="action-buttons">
          <button
            id="train_btn"
            class="train-button modern-train-btn"
            onclick="startTraining()"
          >
            <span class="material-symbols-outlined">psychology</span>
            <span class="btn-text">Start Training</span>
            <div class="btn-ripple"></div>
          </button>
        </div>
        <div class="header-controls">
          <button
            id="settings_btn"
            class="settings-button"
            onclick="goToSettings()"
          >
            <span class="material-symbols-outlined">settings</span>
          </button>

          <button id="addTabButton" class="add-tab-button">+ Add Plot</button>
        </div>
      </header>

      <!-- Sensor metrics cards -->
      <div class="metrics-container">
        <div class="metric-card compact">
          <div class="metric-header">
            <span class="material-symbols-outlined">device_thermostat</span>
            <span class="metric-title">Soil Temperature</span>
          </div>
          <div class="metric-value">
            <span id="temp-value">--</span>
            <span class="metric-unit">°C</span>
          </div>
        </div>

        <div class="metric-card compact">
          <div class="metric-header">
            <span class="material-symbols-outlined">water_drop</span>
            <span class="metric-title">Soil Humidity</span>
          </div>
          <div class="metric-value">
            <span id="humidity-value">--</span>
            <span class="metric-unit">%</span>
          </div>
        </div>

        <div class="metric-card compact">
          <div class="metric-header">
            <span class="material-symbols-outlined">compress</span>
            <span class="metric-title">Soil Tension</span>
          </div>
          <div class="metric-value">
            <span id="tension-value">--</span>
            <span class="metric-unit">cb</span>
          </div>
        </div>

        <div class="metric-card compact pump-card">
          <div class="metric-header">
            <span class="material-symbols-outlined">water_pump</span>
            <span class="metric-title">Water Pump</span>
            <span
              class="tooltip material-symbols-outlined"
              data-tooltip-id="pumpTooltip"
              >help
              <span class="tooltiptext" id="pumpTooltip"
                >Control and monitor your irrigation pump. Set the amount of
                water to irrigate and schedule irrigation cycles.</span
              >
            </span>
          </div>

          <!-- Row 1: Irrigation Amount Input -->
          <div class="pump-row">
            <label class="pump-label">Irrigation amount:</label>
            <div class="amount-input-group">
              <button
                type="button"
                class="amount-btn decrease"
                onclick="adjustAmount(-1)"
              >
                <span class="material-symbols-outlined">remove</span>
              </button>
              <input
                id="irrigation_value_form"
                type="number"
                min="1"
                max="1000"
                value="10"
                class="amount-input"
              />
              <button
                type="button"
                class="amount-btn increase"
                onclick="adjustAmount(1)"
              >
                <span class="material-symbols-outlined">add</span>
              </button>
              <span class="amount-unit">Ltr</span>
            </div>
          </div>

          <!-- Row 2: Status and Schedule Button -->
          <div class="pump-row">
            <div class="pump-status-section">
              <div id="pump-status" class="status-off">OFF</div>
            </div>
            <button
              id="schedule_irrigation"
              class="schedule-btn"
              onclick="irrigateManually()"
            >
              Schedule Irrigation
            </button>
          </div>
        </div>
      </div>

      <!-- Charts section -->
      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-title-section">
            <h3>Raw captured sensor values</h3>
            <span
              class="tooltip material-symbols-outlined"
              data-tooltip-id="chart_hist_tooltip"
              >help
              <span class="tooltiptext" id="chart_hist_tooltip"></span>
            </span>
          </div>
        </div>
        <div id="chart_hist" class="chart-area"></div>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-title-section">
            <h3>Data as input for machine learning procedure</h3>
            <span
              class="tooltip material-symbols-outlined"
              data-tooltip-id="chart_train_data_tooltip"
              >help
              <span class="tooltiptext" id="chart_train_data_tooltip"></span>
            </span>
          </div>
        </div>
        <div id="chart_train_data" class="chart-area"></div>
      </div>

      <div class="chart-card">
        <div class="chart-header">
          <div class="chart-title-section">
            <h3>Predicted sensor values</h3>
            <span
              class="tooltip material-symbols-outlined"
              data-tooltip-id="chart_pred_tooltip"
              >help
              <span class="tooltiptext" id="chart_pred_tooltip"></span>
            </span>
          </div>
        </div>
        <div id="chart_pred" class="chart-area"></div>
        <p id="timestamp_txt"></p>
      </div>

      <!-- Hidden irrigation form for manual irrigation -->
      <div style="display: none">
        <input id="irrigation_value_form" type="number" value="10" />
        <button id="schedule_irrigation" onclick="irrigateManually()">
          Schedule Irrigation
        </button>
      </div>
    </div>
  </body>
</html>
