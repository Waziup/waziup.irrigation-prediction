<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Settings of the "Irrigation Prediction" WaziApp</title>
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="main.css" type="text/css" />
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet" />
  <script type="text/javascript" src="libs/jquery-3.2.1.min.js"></script>
  <!-- Include the locally hosted ApexCharts -->
  <script type="text/javascript" src="libs/apexcharts.min.js"></script>
  <script type="text/javascript">
    var waitForTraining = true;
    var timestamp = "";
    // Apex charts is rather slow in handeling many datapoints => needs to be restricted
    var MaxValuesToBeDisplayed = 1000;  // TODO: better: restrict API call to wg-edge
    let chartHist = null;
    let chartDataSet = null;
    let chartPred = null;
    let chartHistLoaded = false, chartDataSetLoaded = false, chartPredLoaded = false; // TODO: use!!!
    var TrainingReadyCheck = 10000;     // 10s
    let tabCounter = 0;


    // Event listeners
    document.addEventListener('DOMContentLoaded', function () {
      // Tooltips
      fetch('tooltips.json')  // Replace with the correct path to your JSON file
        .then(response => response.json())
        .then(tooltips => {
          // Loop through each tooltip element
          document.querySelectorAll('.tooltip').forEach(tooltip => {
            const tooltipId = tooltip.getAttribute('data-tooltip-id');
            // Set the tooltip text from the JSON file
            if (tooltips[tooltipId]) {
              tooltip.querySelector('.tooltiptext').textContent = tooltips[tooltipId];
            }
          });
        })
        .catch(error => console.error('Error loading tooltip text:', error));

      // Get plots formerly saved TODO: call different function from here, this creates plots
      fetch(`../api/getPlots`)
        .then((response) => response.json())
        .then((data) => {
          if (data.tabnames.length == 0) {
            // First Plot, added manually
            addTab("Plot 1")
            // Add plot to backend
            fetch(`../api/addPlot`)
              .then((response) => response.json())
              .then((data) => {
                console.log("Next Plot was added with nr: ", data.next_number);
              });
            // Switch to first tab
            switchTab(1);
          } else {
            // Add saved plots, fetched from backend
            for (let i = 0; i < data.tabnames.length; i++) {
              addTab(data.tabnames[i]);
            }
            switchTab(1)
          }
          console.log("LoadPlots: ", data);
        });

      // Add plot when add button is clicked
      document.getElementById('addTabButton').addEventListener('click', () => {
        const tabId = ++tabCounter; // Increment tabCounter

        // Create a new tab
        const newTab = document.createElement('div');
        newTab.id = `tab-${tabId}`;
        newTab.className = 'tab';
        newTab.textContent = `Plot ${tabId}`;
        newTab.addEventListener('click', () => switchTab(tabId));

        // Add the new tab to the tabs container
        document.getElementById('tabs').appendChild(newTab);

        // Add plot to backend
        fetch(`../api/addPlot`, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `tab_nr=${tabId}`
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("Next Plot was added with nr: ", data.next_number);
          })
          .catch((error) => {
            console.error("Error, could not add plot_nr: ", error);
          });
          

        // Switch to the new tab
        switchTab(tabId);
      });
    });

    // Add plot without informing backend (called for loading plots from file)
    function addTab(name) {
      const tabId = ++tabCounter; // Increment tabCounter

      // Create a new tab
      const newTab = document.createElement('div');
      newTab.id = `tab-${tabId}`;
      newTab.className = 'tab';

      // Create a label for the tab
      const tabLabel = document.createElement('span');
      tabLabel.textContent = name;// `Plot ${tabId}`;
      tabLabel.addEventListener('click', () => switchTab(tabId));

      // Create a close button
      const closeButton = document.createElement('span');
      closeButton.className = 'close-tab';
      closeButton.innerHTML = '&times;'; // "×" symbol for closing
      closeButton.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevents tab switch when clicking the close button
        removeTab(tabId);
      });

      // Append label and close button to tab
      newTab.appendChild(tabLabel);
      newTab.appendChild(closeButton);

      // Add the new tab to the tabs container
      document.getElementById('tabs').appendChild(newTab);

      return newTab.id
    }

    // Clear data on tab change
    function clearTabContent() {
      // Clear chart containers
      document.getElementById('chart_hist').innerHTML = '';
      document.getElementById('chart_train_data').innerHTML = '';
      document.getElementById('chart_pred').innerHTML = '';

      // Destory the charts
      if (chartHist) {
        chartHist.destroy();
        chartHist = null;
      }
      if (chartDataSet) {
        chartDataSet.destroy();
        chartDataSet = null;
      }
      if (chartPred) {
        chartPred.destroy();
        chartPred = null;
      }

      // Clear sensor values
      document.getElementById('temp-value').textContent = '-- °C';
      document.getElementById('tension-value').textContent = '-- cb';
      document.getElementById('humidity-value').textContent = '-- %';

      // Clear threshold text
      document.getElementById('timestamp_txt').textContent = '';
    }

    function switchTab(tabId) {
      const currentTab = document.getElementById(`tab-${tabId}`);
      // Check if the clicked tab is already active to prevent reloading
      if (currentTab && currentTab.classList.contains('active')) {
        return;
      }
      // Hide content and show loading indicator
      clearTabContent();
      document.querySelector('.center_full').classList.remove('loaded');
      document.getElementById('loading-indicator').style.display = 'block';

      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');

        // Remove close button from all tabs
        const closeButton = tab.querySelector('.close-tab');
        if (closeButton) {
          closeButton.remove();
        }
      });

      // Activate the selected tab
      if (currentTab) {
        currentTab.classList.add('active');

        // Add close button only to the active tab
        const closeButton = document.createElement('span');
        closeButton.className = 'close-tab';
        closeButton.innerHTML = '&times;';
        closeButton.addEventListener('click', (event) => {
          event.stopPropagation(); // Prevent switching tab on close click
          removeTab(tabId);
        });

        // Ensure tab has relative positioning for absolute close button
        currentTab.style.position = 'relative';
        currentTab.appendChild(closeButton);
      } else {
        console.error(`Tab with id tab-${tabId} not found.`);
      }

      // API Call to set plot
      fetch(`../api/setPlot`, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: `currentPlot=${tabId}`
      })
        .then((response) => response.text())
        .then((data) => {
          console.log(data);
          // Load data for the new tab
          loadStuff();
          //reloadTabContent();
        })
        .catch((error) => {
          console.error("Error, could not set plot_nr: ", error);
        })
        .finally(() => {
          // Hide the loading indicator after the data is loaded TODO: show after threshold
          //document.getElementById('loading-indicator').style.display = 'none';
          //document.querySelector('.center_full').classList.add('loaded');
        });
    }

    // To close an currently active tab
    function removeTab(tabId) {
      const tabToRemove = document.getElementById(`tab-${tabId}`);
      if (tabToRemove) {
        tabToRemove.remove();

        // If the removed tab was active, switch to the next available tab
        if (tabToRemove.classList.contains('active')) {
          const remainingTabs = document.querySelectorAll('.tab');
          if (remainingTabs.length > 0) {
            const nextTab = remainingTabs[remainingTabs.length - 1]; // Switch to last tab
            const nextTabId = nextTab.id.split('-')[1];
            switchTab(nextTabId);
          }
        }
        // API Call to set plot
        fetch(`../api/removePlot`, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `currentPlot=${tabId}`
        })
          .then((response) => response.text())
          .then((data) => console.log(data))
          .catch((error) => console.error("Error in removeTab():", error));

      }
    }

    // Reload div on tab change and add tab
    function reloadTabContent() {
      const tabContent = document.querySelector('.tabContent');

      tabContent.style.display = 'none';  // Hide the div
      setTimeout(() => {
        tabContent.style.display = 'block';  // Show it again after a small delay
      }, 10);  // Short delay to trigger reflow

      console.log("Tab content reloaded visually!");
    }

    // Nav
    function goToSettings() {
      window.location.href = "settings.html";
    }

    // JavaScript function to toggle visibility
    function showElements() {
      var inputElements = document.querySelector(".input_elements");
      inputElements.style.display = "block";
    }

    // Display Snesor values and other elements
    function displaySensorsAndElements(sensorList) {
      // Get the <select> element by its ID
      const selectElement = document.getElementById("sensor_list");
      showElements();

      // Loop through the sensor names and create <option> elements
      sensorList.forEach((sensor) => {
        // Create an <option> element
        const optionElement = document.createElement("option");

        // Set the value and text of the <option> element
        optionElement.value = sensor.deviceId + "/" + sensor.sensorId;
        optionElement.text = sensor.deviceName + " / " + sensor.sensorName;

        // Append the <option> element to the <select> element
        selectElement.appendChild(optionElement);
      });
    }

    // Creates List of sensors
    function parseSensorData(jsonData) {
      const sensorList = [];

      // Loop through the array of objects (devices) in jsonData
      jsonData.forEach((device) => {
        // Check if the device has a "sensors" property
        if (device.sensors && Array.isArray(device.sensors)) {
          // Loop through the sensors array of the device
          device.sensors.forEach((sensor) => {
            // Extract sensor information
            const sensorInfo = {
              deviceId: device.id,
              deviceName: device.name,
              sensorId: sensor.id,
              sensorName: sensor.name,
              sensorValue: sensor.value,
            };

            // Push the sensor information to the sensorList
            sensorList.push(sensorInfo);
          });
        }
      });
      return sensorList;
    }

    // States

    function stateConfigPresent() {
      set_button = document.getElementById('settings_btn');
      set_button.classList.remove('highlight');
      train_button = document.getElementById('train_btn');
      train_button.className = 'button-cancel';
      train_button.disabled = false;
    }

    function stateConfigNotPresent(){
      // Hide the loading indicator, there is no cnfig
      document.getElementById('loading-indicator').style.display = 'none';
      document.querySelector('.center_full').classList.add('loaded');
      alert(
        "Please press the 'Settings' button and set up the needed parameters."
      );
      set_button = document.getElementById('settings_btn');
      set_button.classList.add('highlight');
      train_button = document.getElementById('train_btn');
      train_button.className = 'button-cancel';
      train_button.disabled = true;
    }

    // To confirm that user had run the config
    function checkConfigPresent() {
      return fetch(`../api/checkConfigPresent`)
        .then((response) => response.json())
        .then((data) => {
          if (data.data.config_present == true) {
            stateConfigPresent();
            return true;
          } else {
            // TODO: do not display chart or do display without values
            stateConfigNotPresent();
          }
          console.log(data);
          return false;
        });
    }

    // To confirm that user had run the config
    function checkActiveIrrigation() {
      return fetch(`../api/checkActiveIrrigation`)
        .then((response) => response.json())
        .then((data) => {
          if (data.data.activeIrrigation == true) {
            return true;
          } else {
            // could be capsulated
            var text = document.getElementById('active_passiv');
            var button = document.getElementById('schedule_irrigation');
            text.className = 'value_inactive';
            text.innerText = 'Inactive - No present';
            button.className = 'button-cancel';
            button.disabled = true;
            return false;
          }
          console.log(data);
        });
    }

    // Function to format ISO timestamp to a readable format
    function formatTimestamp(isoTimestamp) {
      const date = new Date(isoTimestamp);
      const options = {
        year: "numeric",
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit" /*, second: '2-digit'*/,
      };
      const formatter = new Intl.DateTimeFormat("de-DE", options);
      return formatter.format(date);
    }

    // Get data from to display inside chart from backend
    function fetchCurrentValues() {
      fetch("../api/getValuesForDashboard")
        .then((response) => response.json())
        .then((dashboardData) => {
          // set data in html
          document.getElementById('temp-value').textContent = String(dashboardData.temp_average) + ' °C';
          document.getElementById('tension-value').textContent = String(dashboardData.moisture_average) + ' cb';
          document.getElementById('humidity-value').textContent = String(dashboardData.vwc_average) + ' %';
        })
        .catch((error) => console.error("Error fetching data:", error));
    }

    // Get current sensor kind
    function fetchSensorKind() {
      fetch("../api/getSensorKind")
        .then((response) => response.json())
        .then((response_data) => {
          if (response_data) {
            return response_data.SensorKind
          }
        }
        )
    }

    // Get data from to display inside chart from backend
    function fetchHistoricalChartData() {
      // Destroy existing chart instance
      if (chartHist) {
        chartHist.destroy();
      }

      fetch("../api/getHistoricalChartData")
        .then((response) => response.json())
        .then((chartData) => {
          const chartContainer = document.getElementById('chart_hist');
          if (chartData.available == false) {
            chartContainer.innerHTML = "";            // Clears the chart div
            chartContainer.style.display = "none";    // Hide the div
          } else {
            chartContainer.style.display = "block";   // Show it when there’s data

            // Limit the number of values to display
            const totalValues = chartData.timestamps.length;

            if (totalValues > MaxValuesToBeDisplayed) {
              const step = Math.ceil(totalValues / MaxValuesToBeDisplayed);

              chartData.timestamps = chartData.timestamps.filter((timestamp, index) => index % step === 0);
              chartData.temperatureSeries = chartData.temperatureSeries.filter((value, index) => index % step === 0);
              chartData.moistureSeries = chartData.moistureSeries.filter((value, index) => index % step === 0);
            }
            // Format the data
            var temperatureSeriesRounded = chartData.temperatureSeries.map(
              (value) => parseFloat(value.toFixed(1))
            );
            var moistureSeriesRounded = chartData.moistureSeries.map((value) =>
              parseFloat(value.toFixed(2))
            );
            var formattedTimestamps = chartData.timestamps.map((timestamp) =>
              formatTimestamp(timestamp)
            );
            //var sensorKind = fetchSensorKind(); // 

            var options = {
              chart: {
                type: "line",
                title: "Temperature and Soil Moisture", // Set the title here
              },
              series: [
                {
                  name: "Temperature in °C",
                  data: temperatureSeriesRounded,
                },
                {
                  name: chartData.unit,
                  data: moistureSeriesRounded,
                },
              ],
              xaxis: {
                categories: formattedTimestamps, //chartData.timestamps,//formattedTimestamps,
                labels: {
                  rotate: -45, // Rotate labels by -45 degrees to avoid overlapping
                  minHeight: 40, // Set a minimum height for labels to prevent overlapping
                  // datetimeFormatter: {
                  //     year: 'yyyy',
                  //     month: 'MMM \'yy',
                  //     day: 'dd MMM',
                  //     hour: 'HH:mm',
                  //     minute: 'HH:mm'
                  // }
                },
              },
            };

            // Hide the loading indicator after the data is loaded
            document.getElementById('loading-indicator').style.display = 'none';
            document.querySelector('.center_full').classList.add('loaded');

            chartHist = new ApexCharts(
              document.querySelector("#chart_hist"),
              options
            );
            chartHist.render();
          }
        })
        .catch((error) => console.error("Error fetching data:", error));
    }

    // TODO: keys are wrong, data missing
    function fetchDatasetChartData() {
      // Destroy existing chart instance
      if (chartDataSet) {
        chartDataSet.destroy();
      }

      fetch("../api/getDatasetChartData")
        .then((response) => response.json())
        .then((chartData) => {
          const chartContainer = document.getElementById('chart_train_data');
          if (chartData.model == false) {
            chartContainer.innerHTML = "";            // Clears the chart div
            chartContainer.style.display = "none";    // Hide the div
          } else {
            chartContainer.style.display = "block";   // Show it when there’s data
            // Initialize variables outside the loop
            var elementsToDisplay = [];
            var formattedTimestamps;
            const totalValues = chartData.timestamps.length;
            const step = Math.ceil(totalValues / MaxValuesToBeDisplayed);

            // Iterate through the keys in chartData
            for (var key in chartData) {
              if (chartData.hasOwnProperty(key)) {
                // Check the type for each element in the array
                var isNumberArray = chartData[key].every(
                  (value) => typeof value === "number"
                );

                if (isNumberArray) {
                  if (totalValues > MaxValuesToBeDisplayed) {
                    chartData[key] = chartData[key].filter((value, index) => index % step === 0);
                  }
                  // If all elements are numbers, push the series data
                  elementsToDisplay.push({
                    name: key,
                    data: chartData[key].map((value) =>
                      parseFloat(value.toFixed(2))
                    ),
                  });
                } else if (typeof chartData[key][0] === "string") {
                  if (totalValues > MaxValuesToBeDisplayed) {
                    chartData[key] = chartData[key].filter((value, index) => index % step === 0);
                  }
                  formattedTimestamps = chartData.timestamps.map(
                    (timestamp) => formatTimestamp(timestamp)
                  );
                }
              }
            }

            var options = {
              chart: {
                type: "line",
                title: "All values of the dataset", // Set the title here
              },
              series: elementsToDisplay, // Use the prepared series data
              xaxis: {
                categories: formattedTimestamps || [], // Use formattedTimestamps if available, otherwise an empty array
                labels: {
                  rotate: -45,
                  minHeight: 40,
                },
              },
            };

            chartDataSet = new ApexCharts(
              document.querySelector("#chart_train_data"),
              options
            );
            chartDataSet.render();

            // Hide some series after rendering
            chartDataSet.hideSeries("hour");
            chartDataSet.hideSeries("Cloudcover");
            chartDataSet.hideSeries("Shortwave_Radiation");
            chartDataSet.hideSeries("Soil_temperature_7-28");
            chartDataSet.hideSeries("Soil_moisture_0-7");
            chartDataSet.hideSeries("Et0_evapotranspiration");
          }
        })
        .catch((error) => console.error("Error fetching data:", error));
    }

    function fetchPredictionChartData() {
      // Destroy existing chart instance
      if (chartPred) {
        chartPred.destroy();
        chartPred = null;
      }

      fetch("../api/getPredictionChartData")
        .then((response) => response.json())
        .then((chartData) => {
          const chartContainer = document.getElementById('chart_pred');
          chartContainer.innerHTML = "";            // Clears the chart div
          if (chartData.model === false) {
            chartContainer.style.display = "none";    // Hide the div
            // highlight train
            const trainButton = document.getElementById("train_btn");
            trainButton.classList.add("highlight");
            alert('Please start training by pressing the "Start Training" button.'); //TODO: this needs to be capsulated and also checked for training in progress REFINE!!!
          } else {
            chartContainer.style.display = "block";   // Show it when there’s data
            // Format the data
            const moistureSeriesRounded = chartData.moistureSeries.map((value) =>
              parseFloat(value.toFixed(2))
            );
            let moistureSeriesVolRounded = null;
            if (chartData.kind === "tension" && Array.isArray(chartData.moistureSeriesVol)) {
              moistureSeriesVolRounded = chartData.moistureSeriesVol.map((value) =>
                parseFloat(value.toFixed(4))
              );
            }
            const formattedTimestamps = chartData.timestamps.map((timestamp) =>
              formatTimestamp(timestamp)
            );

            // Initialize series visibility state TODO: check for capcitive
            const seriesVisibility = {
              "Moisture in cbar (Soil Tension)": true,
              "Volumetric Water Content": false,
            };

            // Configure chart options
            const options = {
              chart: {
                type: "line",
                events: {
                  render: function (chartContext, config) {
                    // Make sure the series exists before calling hideSeries
                    if (chartData.kind === "tension" && moistureSeriesVolRounded) {
                      chartPred.hideSeries("Volumetric Water Content");
                    }
                  },
                  legendClick: function (chartContext, seriesIndex) {
                    const seriesName = chartContext.w.globals.seriesNames[seriesIndex];
                    // Toggle visibility state for the clicked series
                    seriesVisibility[seriesName] = !seriesVisibility[seriesName];

                    // Determine the new annotations
                    const annotations = seriesVisibility["Moisture in cbar (Soil Tension)"]
                      ? getSoilTensionAnnotations(chartData)
                      : [];

                    // Additional annotations from backend, like 
                    const additionalAnnotations = seriesVisibility["Moisture in cbar (Soil Tension)"]
                      ? chartData.annotations.yaxis
                      : [];

                    // Update the chart annotations
                    chartContext.updateOptions({
                      annotations: {
                        yaxis: [...annotations, ...additionalAnnotations],
                      },
                    });
                  },
                },
              },
              series: [
                {
                  name: chartData.unit,
                  data: moistureSeriesRounded,
                },
                ...(moistureSeriesVolRounded
                  ? [
                    {
                      name: "Volumetric Water Content",
                      data: moistureSeriesVolRounded,
                    },
                  ]
                  : []),
              ],
              xaxis: {
                categories: formattedTimestamps,
                labels: {
                  rotate: -45,
                  minHeight: 40,
                },
              },
              yaxis: [
                {
                  title: {
                    text: chartData.unit,
                  },
                  labels: {
                    formatter: function (val) {
                      return typeof val === "number" && !isNaN(val) ? val.toFixed(1) : "";
                    },
                  },
                  min: 0,
                  max: Math.max(...moistureSeriesRounded),
                },
                ...(moistureSeriesVolRounded
                  ? [
                    {
                      opposite: true,
                      title: {
                        text: "Volumetric Water Content",
                      },
                      labels: {
                        formatter: function (val) {
                          return typeof val === "number" && !isNaN(val)
                            ? val.toFixed(2)
                            : "";
                        },
                      },
                      min: Math.min(...moistureSeriesVolRounded).toFixed(0),
                      max: Math.max(...moistureSeriesVolRounded).toFixed(0),
                    },
                  ]
                  : []),
              ],
              annotations: {
                yaxis: [
                  ...(() => {
                    if (chartData.kind === 'tension') {
                      // Combine both soil tension annotations and the other y-axis annotations
                      const soilTensionAnnotations = getSoilTensionAnnotations(chartData);
                      const additionalAnnotations = Array.isArray(chartData.annotations?.yaxis)
                        ? chartData.annotations.yaxis
                        : [];
                      return [...soilTensionAnnotations, ...additionalAnnotations];
                    }
                    // Return only the additional annotations if not tension
                    return Array.isArray(chartData.annotations?.yaxis)
                      ? chartData.annotations.yaxis
                      : [];
                  })(),
                ],
                xaxis: getMidnightAnnotations(chartData.timestamps), // Add midnight annotations here
                legend: {
                  show: true, // Ensure the legend is always shown
                },
              }
            };

            chartPred = new ApexCharts(
              document.querySelector("#chart_pred"),
              options
            );
            chartPred.render();
          }
        })
        .catch((error) => console.error("Error fetching data:", error));
    }

    // Function to get midnight annotations
    function getMidnightAnnotations(timestamps) {
      days = 0
      return timestamps
        .filter((timestamp) => new Date(timestamp).getHours() === 0 && new Date(timestamp).getMinutes() === 0)
        .map((midnight) => ({
          x: formatTimestamp(midnight),
          borderColor: '#FF5733', // Choose any color you like for midnight lines
          strokeDashArray: 4, // Dashed lines
        }));
    }

    // Get active series dynamically
    function getActiveSeries(chartContext) {
      const activeSeries = [];
      chartContext.w.globals.seriesNames.forEach((name, index) => {
        // A series is active if its value is not null
        if (chartContext.w.globals.series[index] !== null) {
          activeSeries.push(name);
        }
      });
      return activeSeries;
    }

    // Initial annotations function
    function getInitialAnnotations(chartData) {
      if (chartData.kind === "tension") {
        return getSoilTensionAnnotations(chartData);
      }
      return [];
    }

    // Function to get annotations for soil tension with colored areas
    function getSoilTensionAnnotations(chartData) {
      return [
        // Area between Saturation and Field Capacity Lower
        {
          y: chartData.fieldCapacityLower,
          borderColor: "transparent",
          label: {
            text: "Saturation",
            style: {
              fontSize: "12px",
            },
            position: 'right', // Align to the right
            offsetY: 50, // Vertical offset for middle alignment
            offsetX: 0, // Horizontal offset for right alignment
          },
          offsetX: 0,
          offsetY: 0,
          shape: 'rect',
          x: chartData.timestamps.length - 1, // Rightmost position to cover the area
          fillColor: "rgba(173, 216, 255, 0.5)", // Color for this area (light blue)
          y2: chartData.saturation, // Ending y value to create the filled area
        },
        // Area between Field Capacity Lower and Field Capacity Upper
        {
          y: chartData.fieldCapacityUpper,
          borderColor: "transparent",
          label: {
            text: "Field Capacity Lower",
            style: {
              fontSize: "12px",
            },
            position: 'right', // Align to the right
            offsetY: 50, // Vertical offset for middle alignment
            offsetX: 0, // Horizontal offset for right alignment
          },
          offsetX: 0,
          offsetY: 0,
          shape: 'rect',
          x: chartData.timestamps.length - 1, // Rightmost position to cover the area
          fillColor: "rgba(144, 238, 144, 0.5)", // Color for this area (light green)
          y2: chartData.fieldCapacityLower, // Ending y value to create the filled area
        },
        {
          y: chartData.permanentWiltingPoint,
          borderColor: "transparent",
          label: {
            text: "Field Capacity Higher",
            style: {
              fontSize: "12px",
            },
            position: 'right', // Align to the right
            offsetY: 50, // Vertical offset for middle alignment
            offsetX: 0, // Horizontal offset for right alignment
          },
          offsetX: 0,
          offsetY: 0,
          shape: 'rect',
          x: chartData.timestamps.length - 1, // Rightmost position to cover the area
          fillColor: "rgba(255, 200, 124, 0.5)", // Color for this area (light orange)
          y2: chartData.fieldCapacityUpper, // Ending y value to create the filled area
        },
        {
          y: Math.max(...chartData.moistureSeries).toFixed(0),
          borderColor: "transparent",
          label: {
            text: "Permanent Wilting Point",
            style: {
              fontSize: "12px",
            },
            position: 'right', // Align to the right
            offsetY: 50, // Vertical offset for middle alignment
            offsetX: 0, // Horizontal offset for right alignment
          },
          offsetX: 0,
          offsetY: 0,
          shape: 'rect',
          x: chartData.timestamps.length - 1, // Rightmost position to cover the area
          fillColor: "rgba(255, 182, 193, 0.5)", // Color for this area (light red)
          y2: chartData.permanentWiltingPoint // Ending y value to create the filled area
        },
      ];
    }


    function fetchThreshold() {
      fetch("../api/getThreshold")
        .then((response) => response.json())
        .then((timestamp_data) => {
          if (timestamp_data.threshold == false) {
            console.log(
              "No timestamp, when threshold is reached, could be fetched from backend."
            );
            document.getElementById("timestamp_txt").innerHTML =
              "The threshold is not reached in the current forecast horizon.";
          } else {
            document.getElementById("timestamp_txt").innerHTML =
              "The threshold will be reached on " + timestamp_data.timestamp;
          }
        });
    }

    function canBeParsedToInt(str) {
      let parsed = parseInt(str, 10);
      return !isNaN(parsed);
    }

    // manually irrigate an amount
    function irrigateManually() {
      let amount;
      // Get the input element
      const inputElement = document.getElementById("irrigation_value_form");

      if (canBeParsedToInt(inputElement.value)) {
        amount = parseInt(inputElement.value, 10);

        // Send the amount via a fetch request
        fetch(`../api/irrigateManually?amount=${amount}`)
          .then((response) => response.text())
          .then((data) => {
            dataObject = JSON.parse(data);
            if (dataObject.status == "success") {
              alert(
                "Manual Irrigation was scheduled, will be performed within the next uplink cycle. Do not press this button again until irrigation is completed."
              );
            } else {
              alert("Cannot schedule irrigation, see console for more info! Error:", data);
            }
            console.log(data);
          })
          .catch((error) => {
            console.error('Error:', error);
            alert("An error occurred during the request. Please try again.");
          });

      }
      else {
        alert(
          "First type a valid amount in liters to be irrigated!"
        );
      }

    }


    // start training, encapsulated in create_model.py
    function startTraining() {
      fetch(`../api/startTraining`)
        .then((response) => response.text())
        .then((data) => {
          if (data == "") {
            //location.reload();
            alert(
              "Training process was started, page will reload when procedure is finished!"
            );
            train_button = document.getElementById('train_btn');
            train_button.classList.remove('highlight');
            waitForTraining = true;
            isTrainingReady();
          } else {
            alert("Cannot start, see console for more info! Error:", data);
          }
          console.log(data);
        });
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function isTrainingReady() {
      while (waitForTraining) {
        fetch(`../api/isTrainingReady`)
          .then((response) => response.json())
          .then((response_data) => {
            if (response_data.isTrainingFinished == true) {
              waitForTraining = false;
              //location.reload(); // need to reload div
              loadStuff();
              //reloadTabContent();
              alert("Training process is finished!");
            }
          });
        await sleep(TrainingReadyCheck);
      }
    }

    // Main function
    function loadStuff() {
      $.get("/devices", function (data) {
        checkConfigPresent()
        //TODO: put checkActiveIrrigation() here to have it displayed
          .then((ret) => {
            if (ret) {
              // Config is present
              console.log("Config is already present...");
              return Promise.all([
                checkActiveIrrigation(),
                fetchHistoricalChartData(),
                fetchCurrentValues(),
                fetchDatasetChartData(),
                fetchPredictionChartData(),
                fetchThreshold()
              ]);
              //checkActiveIrrigation()
              //fetchHistoricalChartData();
              //fetchCurrentValues();
              //fetchDatasetChartData();
              //fetchPredictionChartData();
              //fetchThreshold();
            }
          })
          .catch((e) => {
            // alert(
            //   "Please press the settings button and set up the needed Parameters"
            // );
            console.log("Config is not present... Error: ", e);
          });
      });
    }

    // Called on page load => shows loading animation
    $(function () {
      $("#sensor_list")
        .html('<img src="./loading.gif" /> Loading...')
        .fadeIn();
      //loadStuff();
    });
  </script>
</head>

<body>
  <div class="tab-container">
    <div id="tabs" class="tabs">
      <!-- <button id="tab-1" class="tab">Plot 1</button> -->
    </div>
    <div>
      <button id="addTabButton" class="add-tab-button">+ Add Plot</button>
    </div>
  </div>
  <div class="tabContent" class="tab-content">
    <!-- Loading Indicator -->
    <div id="loading-indicator" class="loading-indicator">
      <img src="load-35_256.gif" alt="Loading..." /> <!-- Replace with your spinner GIF -->
      <p>Loading the current plot: Getting data from APIs, datasets, predictions and models...</p>
    </div>
    <div class="action-buttons">
      <button id="settings_btn" class="settings" type="button" onclick="goToSettings()">
        Settings
      </button>
      <button id="train_btn" class="training" type="button" onclick="startTraining()">
        Start Training
      </button>
    </div>
    <div class="center_full">
      <div class="text-content">
        <img src="./logo_irrigation_prediction.jpg" class="logo-content" alt="Irrigation Prediction Logo" />
        <h1>WaziUp Irrigation Prediction</h1>
        <p>
          This application predicts soil moisture values for sensors attached to
          the WaziGate.
        </p>
      </div>

      <div class="quick-view-container">
        <div class="sensor-container">
          <h3 class="sensor-heading">Sensor Readings
            <span class="tooltip material-symbols-outlined" data-tooltip-id="sensorTooltip">help
              <span class="tooltiptext" id="sensorTooltip"></span>
            </span>
          </h3>
          <div class="sensor-value">
            <span class="description">Temperature:</span>
            <span id="temp-value">-- °C</span>
          </div>
          <div class="sensor-value">
            <span class="description">Soil tension:</span>
            <span id="tension-value">-- cb</span>
          </div>
          <div class="sensor-value">
            <span class="description">Soil humidity:</span>
            <span id="humidity-value">-- %</span>
          </div>
        </div>

        <div class="irrigation-container">
          <h3 class="irrigation-heading">Irrigation Status
            <span class="tooltip material-symbols-outlined" data-tooltip-id="irrigationTooltip">help
              <span class="tooltiptext" id="irrigationTooltip"></span>
            </span>
          </h3>
          <div class="irrigation-value">
            <span class="description">Pump Status:</span>
            <span id="active_passiv" class="value_active">Active</span>
          </div>
          <div class="irrigation-value">
            <label for="irrigation-value-input">Irrigation amount in liters</label>
            <input id="irrigation_value_form" type="number" name="irrigation_value" value="10" />
          </div>
          <div class="action-buttons">
            <button id="schedule_irrigation" class="settings" type="button" onclick="irrigateManually()">
              Schedule an Irrigation
            </button>
          </div>
        </div>
      </div>
      <div class="chart-container">
        <p>Raw captured sensor values:
          <span class="tooltip material-symbols-outlined" data-tooltip-id="chart_hist_tooltip">help
            <span class="tooltiptext" id="chart_hist_tooltip"></span>
          </span>
        </p>
        <div id="chart_hist"></div>
      </div>
      <div class="chart-container">
        <p>Data as input for machine learning procedure:
          <span class="tooltip material-symbols-outlined" data-tooltip-id="chart_train_data_tooltip">help
            <span class="tooltiptext" id="chart_train_data_tooltip"></span>
          </span>
        </p>
        <div id="chart_train_data"></div>
      </div>
      <div class="chart-container">
        <p>Predicted sensor values:
          <span class="tooltip material-symbols-outlined" data-tooltip-id="chart_pred_tooltip">help
            <span class="tooltiptext" id="chart_pred_tooltip"></span>
          </span>
        </p>
        <div id="chart_pred"></div>
        <p id="timestamp_txt"></p>
      </div>
    </div>
  </div>
</body>

</html>